---
title: "Basic objects and data types in R"
teaching: 50
exercises: 30
questions:
  - "What are the basic data structures and data types in R?"
  - "How can values be assigned to objects?"
  - "How can subsets be extracted from vectors?"
  - "What are the basic quality control checks that should be done when importing data?"
  - "How can we deal with missing values in R?"
objectives: 
  - "Assign values to objects in R."
  - "Use functions and access their documentation."
  - "Distinguish between the following terms: object, assign, function, arguments, options."
  - "Understand and distinguish between two fundamental vector types: numeric and character."
  - "Subset and extract values from vectors."
keypoints:
  - "Access individual values by location using `[]`."
  - "Access arbitrary sets of data using `[c(...)]`."
source: Rmd
---

```{r, include=FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("01-")
```


## Creating objects in R

Often, you want to save the output of an operation for using later. 
In other words, we need to assign **values** to **objects**. 
To create an object, we need to give it a name followed by the
**assignment operator** `<-`, and the value we want to give to it.

For example: 

```{r, purl=FALSE}
area_hectares <- 1
```

We can read the code as: the _value_ 1 is _assigned_ to the _object_ area_hectares. 
Note that when you run this line of code the object you just created appears on 
your _environment_ tab (top-right panel).

When assigning a value to an object, R does not print anything on the console. 
You can print the value by typing the object name on the console:

```{r, purl=FALSE}
area_hectares
```


> ## Naming objects
> 
> Object names can contain letters, numbers, underscores and periods. They
> _cannot start with a number nor contain spaces_. Different people use
> different conventions for long variable names, two common ones:
> 
> - Underscore: `my_long_named_object`
> - Camel case: `myLongNamedObject`
> 
> What you use is up to you, but **be consistent**.
> 
> Also note that R is case-sensitive so `area_hectares` is different from `Area_hectares`.
{: .callout}
<p></p>

Now that R has `area_hectares` in memory, we can do operations with it. 
For instance, we may want to convert this area into acres (area in acres is 2.47 
times the area in hectares):

```{r, purl=FALSE}
2.47 * area_hectares
```

We can also change an object's value by assigning it a new one:

```{r, purl=FALSE}
area_hectares <- 2.5
2.47 * area_hectares
```

Finally, assigning a value to one object does not change the values of other objects. 
For example, let's store the plot's area in acres in a new object, `area_acres`:

```{r, purl=FALSE}
area_acres <- 2.47 * area_hectares
```

and then change `area_hectares` to 50.

```{r, purl=FALSE}
area_hectares <- 50
```

Note that this did not change the value of `area_acres`. 

> ### Keyboard shortcut
> 
> In RStudio, the keyboard shortcut for `<-` is <kbd>Alt</kbd> + <kbd>-</kbd> (PC) or 
> <kbd>&#8984;</kbd> + <kbd>-</kbd> (Mac).
{: .callout}


> ## Exercise
> 
> What is the value of `bmi` after running the following four lines of code:
>
> ```{r, eval = FALSE}
> weight_kg <- 70
> height_m <- 1.80
> bmi <- weight_kg/(height_m^2)
> weight_kg <- 62
> ```
>
> > ## Solution
> >
> > The value of `bmi` is 21.6 because it's the result of 70/(1.8^2).
> > Changing the `weight_kg` afterwards did not affect the `bmi` object.
> {: .solution}
{: .challenge}


## Functions and their arguments

Functions perform specific operations or tasks in R. A **function**
usually gets one or more inputs called **arguments**. Functions often (but not
always) return a **value**. A typical example would be the function `sqrt()`. The
input (the argument) must be a number, and the return value (in fact, the
output) is the square root of that number. Executing a function ('running it')
is called *calling* the function. An example of a function call is:

```{r, eval=FALSE, purl=FALSE}
b <- sqrt(a)
```

Here, the value of `a` is given to the `sqrt()` function, the `sqrt()` function
calculates the square root, and returns the value which is then assigned to
the object `b`. This function is very simple, because it takes just one argument.

The return 'value' of a function need not be numerical (like that of `sqrt()`),
and it also does not need to be a single item: it can be a set of things, or
even a dataset. We'll see that when we read data files into R.

Arguments can be anything, not only numbers or filenames, but also other
objects. Exactly what each argument means differs per function, and must be
looked up in the documentation (detailed below). Some functions take arguments which
may either be specified by the user, or, if left out, take on a *default* value:
these are called *options*. Options are typically used to alter the way the
function operates. 

Let's try a function that can take multiple arguments: `round()`.

```{r, results='show', purl=FALSE}
round(3.14159)
```

Here, we've called `round()` with just one argument, `3.14159`, and it has
returned the value `3`.  That's because the default is to round to the nearest
whole number. If we want more digits we can see how to do that by getting
information about the `round` function.  We can look at the help for this function 
using `?round`.

```{r, eval=FALSE, purl=FALSE}
?round
```

We see that if we want a different number of digits, we can type `digits = 2` or 
however many we want.

```{r, results='show', purl=FALSE}
round(3.14159, digits = 2)
```

If you provide the arguments in the exact same order as they are defined you
don't have to name them:

```{r, results='show', purl=FALSE}
round(3.14159, 2)
```

And if you do name the arguments, you can switch their order:

```{r, results='show', purl=FALSE}
round(digits = 2, x = 3.14159)
```

It's good practice to put the non-optional arguments (like the number you're
rounding) first in your function call, and to specify the names of all optional
arguments.  If you don't, someone reading your code might have to look up the
definition of a function with unfamiliar arguments to understand what you're
doing.


## Vectors and data types

A vector is the most common and basic data structure in R. It consists of a collection 
of values that can be created with the `c()` function. For example:

```{r, purl=FALSE}
some_numbers <- c(62, 77, 0, 6)
some_numbers
```

A vector can also contain _character_ values, for example:

```{r, purl=FALSE}
some_animals <- c("cat", "dog", "giraffe", "dog")
some_animals
```

The quotes `""` are essential here. Without the quotes R
will assume there are objects called `cat`, `dog` and `giraffe`. 
As these objects don't exist in R's memory, there would be an error message.

There are many functions that allow you to inspect the content of a
vector. `length()` tells you how many elements are in a particular vector:

```{r, purl=FALSE}
length(some_numbers)
```

The function `class()` indicates the class (the type of element) of an object:

```{r, purl=FALSE}
class(some_numbers)
class(some_animals)
```

> ## data types in R
> 
> The main data types in R are:
> 
> - numeric or double (a number with decimal points)
> - integer (a number with no decimal points)
> - character
> - logical: `TRUE` or `FALSE` (we will discuss these in a future episode)
> 
{: .callout}
<p></p>

You can use the `c()` function to add other elements to your vector:

```{r, purl=FALSE}
c(some_animals, "ant", "fruit fly")
```

Or even combine vectors together:

```{r}
c(some_animals, some_animals)
```

> ### Creating sequences of numbers
> There are several shortcuts to create sequences of numbers, and these can be 
very useful in different situations: 
> 
> ```{r, eval=FALSE}
> 1:10                           # integers from 1 to 10
> 10:1                           # integers from 10 to 1
> seq(1, 10, by = 2)             # from 1 to 10 by steps of 2
> seq(1, 10, by = 0.6)           # from 1 to 10 by steps of 0.5
> seq(1, 10, length.out = 20)    # 20 equally spaced values from 1 to 10
> ```
{: .callout}


### Value coercion

An important thing to be aware of is that **all of the elements in a vector are of 
the same type**. Use the following exercise to see what R does when a vector contains 
a mixed types of values.

> ## Exercise
>
> Use `class()` to check the data type of the following objects:
>
>  ```{r, results="hide"}
>  num_char <- c(1, 2, 3, "a")
>  num_logical <- c(1, 2, 3, TRUE)
>  char_logical <- c("a", "b", "c", TRUE)
>  tricky <- c(1, 2, 3, "4")
>  ```
> > ## Solution
> >
> > ```{r, eval=FALSE}
> > class(num_char)     # is a character
> > class(num_logical)  # is numeric
> > class(char_logical) # is character
> > class(tricky)       # is character because 4 is quoted
> > ```
> {: .solution}
{: .challenge}


You've probably noticed that objects of different types get converted into a single, 
shared type within a vector. In R, we call converting objects from one class into 
another class _coercion_. These conversions happen according to a hierarchy,
whereby some types get preferentially coerced into other types. The hierarchy is:
`character > numeric > integer > logical`


### Subsetting vectors

If we want to extract one or several values from a vector, we must provide one
or several indices in square brackets. For instance:

```{r, results='show', purl=FALSE}
some_animals <- c("cat", "dog", "giraffe", "dog")

# the second element of the vector
some_animals[2]

# the third and second elements of the vector
respondent_wall_type[c(3, 2)]
```

We can also repeat the indices to create an object with more elements than the
original one:

```{r, results='show', purl=FALSE}
some_animals[c(1, 2, 2, 3, 3)]
```


## Missing data

As R was designed to analyze datasets, it includes the concept of missing data. 
Missing data are represented as the value `NA` (with no quotes around it).

Some functions will return `NA` if the data you are working with include missing 
values. This feature makes it harder to overlook the cases where you are dealing 
with missing data. 

```{r, purl=FALSE}
rooms <- c(2, 1, 1, NA, 4)
mean(rooms)
max(rooms)
mean(rooms, na.rm = TRUE)
max(rooms, na.rm = TRUE)
```

If your data include missing values, you may want to become familiar with the
functions `is.na()`, `na.omit()`, and `complete.cases()`. See below for
examples.


```{r, purl=FALSE}
## Extract those elements which are not missing values.
rooms[!is.na(rooms)]

## Returns the object with incomplete cases removed. The returned object is an atomic vector of type `"numeric"` (or `"double"`).
na.omit(rooms)

## Extract those elements which are complete cases. The returned object is an atomic vector of type `"numeric"` (or `"double"`).
rooms[complete.cases(rooms)]
```

> ## Exercise
>
> 1. Using this vector of rooms, create a new vector with the NAs removed.
>
>     ```r
>     rooms <- c(1, 2, 1, 1, NA, 3, 1, 3, 2, 1, 1, 8, 3, 1, NA, 1)
>     ```
> 2. Use the function `median()` to calculate the median of the `rooms` vector.
>
> 3. Use R to figure out how many households in the set use more than 2 rooms for sleeping.
>
> > ## Solution
> > ```{r, answer=TRUE}
> > rooms <- c(1, 2, 1, 1, NA, 3, 1, 3, 2, 1, 1, 8, 3, 1, NA, 1)
> > rooms_no_na <- rooms[!is.na(rooms)]
> > # or
> > rooms_no_na <- na.omit(rooms)
> > # 2.
> > median(rooms, na.rm = TRUE)
> > # 3.
> > rooms_above_2 <- rooms_no_na[rooms_no_na > 2]
> > length(rooms_above_2)
> > ```
> {: .solution}
{: .challenge}



{% include links.md %}
