---
title: "Grouped operations using `dplyr`"
teaching: 50
exercises: 30
questions:

objectives: 
- ""
- "Recognise when to use grouped operations in data analysis."
- "Differentiate between grouped summaries and other types of grouped operations."
- "Apply grouped summaries using the `group_by()` + `summarise()` functions."
- "Apply other grouped operations such as: `group_by()` + `filter()` and `group_by()` + `mutate()`."
- "Recognise the importance of the `ungroup()` function."
keypoints:
- ""
- "As a habit, always remember to `ungroup()` tables after performing grouping operations."
source: Rmd
---

```{r, include=FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("07-")
knitr::opts_chunk$set(fig.width=12, fig.height=7) 
```

```{r, include=FALSE}
# set ggplot2 theme with bigger text size
library(tidyverse)
theme_set(theme_grey() + theme(text = element_text(size = 16)))
```


In this lesson we're going to learn how to use the `dplyr` package to make calculations 
for sub-groups in our data.

As usual when starting an analysis on a new script, let's start by loading the 
packages and reading the data. In this case, let's use the clean dataset that we 
created in the last exercise of the 
[previous episode]({{ page.root }}{% link _episodes/05-manipulate_observations_dplyr.md %}).

```{r, eval=FALSE}
# load the package
library(tidyverse)

# Read the data, specifying how missing values are encoded
gapminder_clean <- read_csv("data/processed/gapminder1960to2010_socioeconomic_clean.csv", 
                            na = "")
```

If you haven't completed the previous exercise, here's how you can recreate the 
clean dataset:

```{r, message=FALSE, warning=FALSE}
gapminder_clean <- read_csv("data/gapminder1960to2010_socioeconomic.csv", na = "") %>% 
  select(-country_id) %>% 
  mutate(population_total = population_male + population_female,
         main_religion = str_to_lower(str_squish(main_religion)),
         life_expectancy_male = ifelse(life_expectancy_male == -999, NA, life_expectancy_male),
         life_expectancy_female = as.numeric(life_expectancy_female)) %>% 
  filter(!is.na(income_groups))
```


## Reshaping

```{r}
income_wide <- gapminder_clean %>% 
  select(country, year, income_per_person) %>% 
  pivot_wider(names_from = "year", 
              names_prefix = "yr",
              values_from = "income_per_person")
income_wide
```

Note that the `names_prefix` argument is optional. Here, we've used it because it's a
good idea to avoid column names that start with a number. In other cases you can omit it.

Now, we could answer our question of interest:

```{r}
income_wide %>% 
  ggplot(aes(yr1960, yr2010)) +
  geom_point() +
  geom_abline() +
  scale_x_continuous(trans = "log10") +
  scale_y_continuous(trans = "log10")
```

The oposite of this operation can be achieved with the `pivot_longer()` function. 
Let's reverse the operation done above:

```{r}
income_wide %>% 
  pivot_longer(cols = contains("yr"),
               names_to = "year", 
               values_to = "income_per_person")
```


## Exercise

- Create a table with life expectancy values, with a row for each year and a column 
  for each country.

- Fix the _pivoting_ step in the following code, which should allow making the graph
  below.
  
```{r, eval=FALSE}
gapminder_clean %>% 
  # retain data from a few years only
  filter(year %in% c(1960, 1970, 1980, 1990, 2010)) %>% 
  # select columns of interest
  select(country, year, life_expectancy_female, life_expectancy_male) %>% 
  # reshape the table
  pivot_longer(cols = FIXME, 
               names_to = "FIXME", 
               values_to = "FIXME") %>% 
  ggplot(aes(factor(year), life_expect)) +
  geom_boxplot(aes(fill = sex))
```

```{r, echo=FALSE, warning=FALSE}
gapminder_clean %>% 
  filter(year %in% c(1960, 1970, 1980, 1990, 2010)) %>% 
  select(country, year, life_expectancy_female, life_expectancy_male) %>% 
  pivot_longer(cols = life_expectancy_female:life_expectancy_male, 
               names_to = "sex", values_to = "life_expect") %>% 
  ggplot(aes(factor(year), life_expect)) +
  geom_boxplot(aes(fill = sex))
```


```{r}
gapminder_clean %>% 
  select(country, year, life_expectancy) %>% 
  pivot_wider(names_from = "country", values_from = "life_expectancy")
```


```{r, warning=FALSE}
gapminder_clean %>% 
  filter(year %in% c(1960, 1970, 1980, 1990, 2010)) %>% 
  select(country, year, life_expectancy_female, life_expectancy_male) %>% 
  pivot_longer(cols = life_expectancy_female:life_expectancy_male, 
               names_to = "sex", values_to = "life_expect") %>% 
  ggplot(aes(factor(year), life_expect)) +
  geom_boxplot(aes(fill = sex))
```


## Joining tables

A common task in data analysis is to bring different datasets together, so that we 
can combine columns from two (or more) tables together. 

This can be achieved using the _join_ family of functions in `dplyr`. There are 
different types of _joins_, which can be represented by a series of Venn diagrams:

![joins](../fig/07-dplyr_joins.svg)

<!--
This can be used to explain joins in class. Maybe add to instructor guidelines.

Let's start by looking at some simple examples using in-built data that come with R.
Take the following two tables:

```{r}
band_members
band_instruments
```

As you can see, we have information about individuals and the music band they play in 
on one table, and the instrument they play on the other table. We can also see that 
not all artists are present on both tables. 

Let's _join_ these two tables and retain only the artists common to both:

```{r}
inner_join(band_members, band_instruments, by = "name")
```

Note that the option `by = "name"` tells the _join_ function what is the column 
(or columns) that should be used to match the different entries in the two tables. 
-->


In the [apendix exercises]({{ page.root }}{% link _episodes/90-appendix-exercises.md %}) 
we've been exploring a dataset related to energy consumption in different counties. 
Let's see how we can _join_ these two datasets together, so that we have all information 
in a single table. 

First, let's start by reading the data in:

```{r}
# it's a tab-separated file, so we use read_tsv
energy <- read_tsv("data/gapminder1990to2010_energy.tsv", 
                   na = "")
```

A critical step when joining tables is to identify which columns are used to "match" 
the rows between them (in database language, these are called the _key_ variables). 
In our case the columns `country`, `world_region` and `year` should, together, have a 
one-to-one match between our two tables. 

We can quickly check that not all countries from `gapminder_clean` are present in 
the `energy` table:

```{r}
# the `all()` function checks whether all values of a logical vector are TRUE
all(gapminder_clean$country %in% energy$country)
```

And the same happens for year:

```{r}
all(gapminder_clean$year %in% energy$year)
```

So, different types of _join_ operations (represented in the figure above) will 
result in different outcomes. 

Let's start by doing a _join_ that retains only the entries common to both tables:

```{r}
inner_join(gapminder_clean, energy, 
           by = c("country", "world_region", "year"))
```

The `by` option is used to tell the _join_ function which columns are used to "match" 
the rows of the two tables. We can see that the output has fewer rows than both of these 
tables, which makes sense given we're only keeping the "intersection" between the two. 
Schematically, this is what happened:

![inner_join](https://d33wubrfki0l68.cloudfront.net/3abea0b730526c3f053a3838953c35a0ccbe8980/7f29b/diagrams/join-inner.png)

The other types of _join_ functions work exactly the same as this one, the only thing 
that changes is what kind of output you get. Schematically:

![outer_joins](https://d33wubrfki0l68.cloudfront.net/9c12ca9e12ed26a7c5d2aa08e36d2ac4fb593f1e/79980/diagrams/join-outer.png)

One important thing to note here is that when doing either of these types of _joins_, 
the functions will take care of filling in the table with missing values, `NA`, whenever 
a row in one table does not have a match in the other table. 


## Exercise

1. Create a new table called `gapminder_all`, which includes all rows from both 
   tables joined together by their common variable _keys_. 
1. Create a new column with CO2 emissions per person. 
   (Optional: make a graph showing how this changed over the years for each country)
2. Use the `anti_join()` function to identify which rows in the `energy` dataset do 
   NOT have a match in our original data. 

```{r}
anti_join(energy, gapminder_clean, by = c("country", "year"))
```


