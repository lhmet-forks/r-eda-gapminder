---
title: "Manipulating variables (columns) with `dplyr`"
teaching: 50
exercises: 30
questions:
- "How to select and/or rename specific columns from a data.frame?"
- "How to create a new column or modify an existing one?"
- "How to 'chain' several commands together with pipes?"
- "How to manipulate _character_ variables to fix some data quality issues?"
objectives: 
- "Use the `dplyr` package to manipulate tabular data (add or modify variables, select and rename columns)."
- "Apply the functions `select()`, `rename()` and `mutate()` to operate on columns."
- "Understand and use 'pipes' as a way to build a chain of operations on data."
- "Discuss some common issues with data cleaning and use functions from the `stringr` package to help solve them."
- "Discuss how to deal with missing data."
keypoints:

source: Rmd
---

```{r, include=FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("04-")
```


In this lesson we're going to learn how to use the `dplyr` package to manipulate columns 
of our data. 

As usual when starting an analysis on a new script, let's start by loading the 
packages and reading the data:

```{r, message=FALSE}
library(tidyverse)

# Read the data, specifying how missing values are encoded
gapminder2010 <- read_csv("data/gapminder2010_socioeconomic.csv", 
                          na = "")
```


## Selecting columns

In an [earlier lesson]() we've seen how to select columns (and rows) of a data frame 
using the square-bracket operator `[rows, columns]`. 
With the `dplyr` package, there is an alternative function, which offers some flexibility 
in how we choose columns. 

Let's start with a simple example of selecting two columns from our table:

```{r}
select(gapminder2010, country, year)
```

Using the _base R_ syntax, this is equivalent to `gapminder2010[, c("country", "year")]`. 
Notice that with the `select()` function (and generally with `dplyr` functions) we 
didn't need to quote `"` the column names. This is because the first input to the 
function is the table name, and so everything after is assumed to be column names 
of that table. 

Where `select()` becomes very convenient is when combined with some other helper functions:

```{r}
# Select columns which have the word "_male" in their name
select(gapminder2010, matches("_male"))
```

And these can be combined in a number of ways:

```{r}
select(gapminder2010, country, matches("_male"), matches("_men"))
```

To see other helper functions to use with `select()` check the following help page 
`?select_helpers`


> ## `dplyr` syntax
> 
> All `dplyr` functions follow the following convention:
> 
> - The first input to the function is always a data.frame/tibble.
> - Next come other inputs specific to the function. Column names usually don't need 
>   to be quoted `"`.
> - The output is always a data.frame/tibble.
{: .callout}


## Creating or modifying columns

To create new columns or modify existing ones, we can use the `mutate()` function. 
Here is an example where we calculate the total population for each country:

```{r}
mutate(gapminder2010, 
       population_total = population_male + population_female)
```

The new column is attached to the end of the table. We can't see its values printed here, 
because there are too many columns, but we can see that it is listed at the bottom of 
the printed result.  

Notice that the `gapminder2010` object did not change, because we didn't assign the 
output of `mutate()` to it. If we want to update our table, then we would do:

```{r}
gapminder2010 <- mutate(gapminder2010, 
                        population_total = population_male + population_female)
```

If we want to check which values it has, then we can use `select()`, as we've learned 
above:

```{r}
select(gapminder2010, 
       country, population_male, population_female, population_total)
```


## Renaming columns 

Use the `rename()` function to change column names, with the following syntax:
`rename(my_table, new_column_name = old_column_name)`. For example:

```{r}
rename(gapminder2010, 
       country_code = country_id, continent = world_region)
```

## Chaining commands with the `%>%` _pipe_

In the examples above, we saw how to perform each of these operations individually. 
But what if we wanted to mutate, then select some columns and rename some of those? 

This type of operation, where we want to _chain_ several commands after each other, 
can be done with *pipes*. In `tidyverse` pipes look like `%>%`. 

Let's see an example in action:

```{r}
gapminder2010 %>% 
  mutate(., population_total = population_male + population_female) %>% 
  select(., country, world_region, population_total) %>% 
  rename(., continent = world_region)
```

Let's break this down:

- We start with the data, `gapminder2010` and "pipe" it (`%>%`) to the next function, 
  `mutate()`.
- In `mutate()` we used the `.` symbol to indicate the input is coming from the previous pipe. 
  And the output will be again "piped" to the next function, `select()`.
- In `select()` we again used the `.` symbol to indicate the input is coming the from previous pipe 
  (i.e. the table with a new column, `population_total` added to it). And again, we send this to...
- `rename()`, which again receives it's input from the pipe. And our chain of commands ends here. 

You interpret the `%>%` as meaning "and then", and so we can "read" the code above as:

> Take the `gapminder2010` table _and then_ add a new column with total population 
> _and then_ select only some of the columns _and then_ rename one of the columns. 

<b>

> ## Using the Dot `.` With `%>%` Pipes 
> 
> In the example above we've explicitly defined that the input to each function 
> is coming from the pipe using the `.` symbol. For example:
> 
> ```{r, eval=FALSE}
> gapminder2010 %>% select(., country, world_regions)
> ```
> 
> However, the `.` can be ommited as the output of the pipe will automatically be 
> passed on as the _first_ input to the next function. The example above can be 
> therefore be more compactly written as:
> 
> ```{r, eval=FALSE}
> gapminder2010 %>% select(country, world_regions)
> ```
> 
> In some cases the use of `.` is needed, if the function that comes after the pipe 
> doesn't take the data frame as it's first argument. For example, the `lm()` function, 
> used to fit _linear models_ (e.g. linear regression) first needs a definition of 
> the model being fitted (the `formula` argument) and only after the data frame 
> (the `data` argument). Check `?lm` documentation to see this is the case. 
> 
> So, if we want to fit a linear regression between life expectancy and income, 
> using a pipe, this is what we would have to do: 
> 
> ```{r, eval=FALSE}
> gapminder2010 %>% lm(formula = life_expectancy ~ income_per_person, data = .)
> ```
> 
> Covering linear models is beyond the scope of this lesson, but the main point is 
> that for this function, because `data` is not the first input to the function, 
> we need to use the `.` explicitly. 
{: .callout}

<b>

The purpose of the pipes is to make the order of the data manipulation steps clear, 
and we will be using them throughout the course. However, they are not mandatory, 
and the same operations could have been done without them. For example, by saving 
the output of each step in a temporary object, which would then be used as input to 
the next function. Here are the same steps as above using this strategy:

```{r}
# First mutate the column of interest
gapminder2010_modified <- mutate(gapminder2010,
                                 population_total = population_male + population_female)

# Then select columns of interest from this modified table
gapminder2010_modified <- select(gapminder2010_modified, 
                                 country, world_region, population_total)

# Finally rename the modified table
rename(gapminder2010_modified, continent = world_region)
```

One clear disadvantage of this approach is that we now have an object `gapminder2010_modified` 
loaded in our _Environment_ (top-right panel of RStudio), which we may actually only 
be interested in temporarily. 

> ## Exercise
> 
> When we [previously explored our data](), we realised that `life_expectancy_female` 
> was imported as a _character_ rather than _numeric_ variable. 
> 
> 1. Modify this variable by _coercing_ it to numeric type (hint: `as.numeric()` will 
>    help here). 
> 2. Make a histogram showing the distribution of the difference between the life expectancy 
>    of the two sexes.
> 
> > ## Answer
> > 
> > Because we want to modify a column, we use the `mutate()` function. We will also 
> > use the `as.numeric()` function to convert the values of `life_expectancy_female` 
> > to numeric:
> > 
> > ```{r}
> > gapminder2010 <- gapminder2010 %>% 
> >   mutate(life_expectancy_female = as.numeric(life_expectancy_female))
> > ```
> > 
> > To create this plot, we can use pipes, to first create a new column using `mutate()` 
> > and then passing the output of that step to `ggplot`:
> > 
> > ```{r}
> > gapminder2010 %>% 
> >   mutate(life_expectancy_female_minus_male = life_expectancy_female - life_expectancy_male) %>% 
> >   ggplot(aes(life_expectancy_female_minus_male)) +
> >   geom_histogram()
> > ```
> {: .answer}
{: .challenge}


## Manipulating categorical data

In this section we're going to use `mutate()` to change some of the categorical 
(character) variables in our dataset. 

The `stringr` package provides several functions to manipulate _strings_ (which is another 
way of saying character values). The functions from that package start with the word 
`str_`, so they are easy to identify. 


```{r}
gapminder2010 %>% 
  mutate(income_groups = str_remove(income_groups, "_income")) %>% 
  mutate(income_groups = str_replace(income_groups, "_", "-"))
```



```{r}
gapminder2010 %>% 
  ggplot(aes(income_groups, income_per_person)) +
  geom_boxplot() +
  scale_y_continuous(trans = "log10")
```


cover:

- data manipulation with `dplyr`: `select()` + `:` + `matches()`, `rename()`, `mutate()`
  - `matches("_male")`
- pipes `%>%`
- Exercise: create column with total population
- factors to improve visualisation: `fct_reorder()` for example?
- more missing data
  - `drop_na()`: how to remove missing data (and when should we do it?)
  - visualise missing data (special `naniar` geometries?) - data not missing at random!
- cleaning up things (or should this go on the next lesson?): `stringr`, `na_if()`
  - `na_if(employment_rate_male, "-")`
  - `na_if(employment_rate_female, "-")`
  - `str_to_lower(main_religion)`
  - `str_trim(main_religion)`
  - `str_remove(income_groups, "_income")`
  - `str_replace(income_groups, "_", "-")`




